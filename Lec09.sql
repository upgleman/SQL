--04 그룹 함수 & 윈도우 함수


--[실습1] 윈도우 함수 - 순위 함수

-- 윈도우 함수 - 순위 함수
-- GYM_MEMBER 테이블에는 멤버 ID, 스쿼트 점수, 벤치 프레스 점수, 데드 리프트 점수 정보가 담겨 있습니다.

-- 각 멤버 ID 별로 스쿼트 점수, 벤치 프레스 점수, 데드 리프트 점수의 합계를 구하고, 합계 점수를 기반으로 순위를 매겨 조회해 봅시다.

-- 이때, 동일 점수는 같은 순위로 취급하지만 단건으로 취급하지 않는 RANK를 이용하여 쿼리를 작성해 봅시다.

-- 지시사항
-- GYM_MEMBER테이블에서 스쿼트 점수, 벤치 프레스 점수, 데드 리프트 점수의 합계 점수에 
-- 대해 동일 점수는 같은 순위로 취급하며, 단건으로 취급하지 않는 순위 함수 RANK를 이용하여 순위를 매겨 조회해봅시다.
-- 결과에서는 멤버 ID(MEMBER_ID), 스쿼트 점수(SQUAT), 벤치 프레스 점수(BENCH_PRESS), 
-- 데드 리프트 점수(DEADLIFT), 합계 점수(WEIGHT_SUM), 순위(RANK) 총 6개의 컬럼을 조회해야 하며, 
-- 이때 순위는 RANK를 이용하고, 합계점수의 내림차순을 기준으로 순위를 세웁니다.

-- 아래는 GYM_MEMBER 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC GYM_MEMBER;

-- 스쿼트 점수, 벤치 프레스 점수, 데드 리프트 점수의 합계에 대해 동일 점수는 같은 순위로 취급하여 순위를 매겨 조회하세요.

select * from GYM_MEMBER;

select MEMBER_ID, SQUAT, BENCH_PRESS, DEADLIFT,
(SQUAT+ BENCH_PRESS+ DEADLIFT) AS WEIGHT_SUM,
RANK() OVER (order by WEIGHT_SUM desc) RANK
from GYM_MEMBER;

+-------------+---------+------+-----+---------+----------------+
| Field       | Type    | Null | Key | Default | Extra          |
+-------------+---------+------+-----+---------+----------------+
| MEMBER_ID   | int(11) | NO   | PRI | NULL    | auto_increment |
| SQUAT       | int(11) | YES  |     | NULL    |                |
| BENCH_PRESS | int(11) | YES  |     | NULL    |                |
| DEADLIFT    | int(11) | YES  |     | NULL    |                |
+-------------+---------+------+-----+---------+----------------+
+-----------+-------+-------------+----------+
| MEMBER_ID | SQUAT | BENCH_PRESS | DEADLIFT |
+-----------+-------+-------------+----------+
|         1 |   110 |          90 |       80 |
|         2 |    40 |          40 |       20 |
|         3 |   250 |         250 |      180 |
|         4 |   330 |         210 |      140 |
|         5 |     5 |           5 |        5 |
|         6 |   330 |         350 |      310 |
+-----------+-------+-------------+----------+
+-----------+-------+-------------+----------+------------+------+
| MEMBER_ID | SQUAT | BENCH_PRESS | DEADLIFT | WEIGHT_SUM | RANK |
+-----------+-------+-------------+----------+------------+------+
|         6 |   330 |         350 |      310 |        990 |    1 |
|         3 |   250 |         250 |      180 |        680 |    2 |
|         4 |   330 |         210 |      140 |        680 |    2 |
|         1 |   110 |          90 |       80 |        280 |    4 |
|         2 |    40 |          40 |       20 |        100 |    5 |
|         5 |     5 |           5 |        5 |         15 |    6 |
+-----------+-------+-------------+----------+------------+------



-- [실습2] 윈도우 함수 - 일반 집계 함수

-- PRODUCT 테이블에는 상품 ID, 상품 이름, 가격 정보가 담겨 있으며 SELL 테이블에는 판매 ID, 상품 ID, 수량, 판매자 이름 정보가 담겨 있습니다.

-- 판매자가 상품별로 판매한 금액 합계를 구하고자 합니다. 이때 상품의 가격 정보는 PRODUCT 테이블에 있기때문에, 
-- JOIN 을 통해 상품의 가격을 가져오고, 가격과 판매 수량을 곱한 금액을 판매자의 이름, 상품 ID 별로 합계를 구해봅시다.

-- SELL 테이블과 PRODUCT 테이블을 상품 ID 기준으로 INNER JOIN을 실시하고, 판매자의 상품별 판매금액 합계를 조회하는 쿼리를 작성해 봅시다.

-- 지시사항
-- SELL 테이블과 PRODUCT 테이블에 대해서 상품 ID(PRODUCT_ID) 를 기준으로 INNER JOIN을 실시하여 판매 ID(SELL_ID), 
-- 판매자 이름(SELLER_NAME), 상품 이름(PRODUCT_NAME), 수량(QUANTITY) 을 조회하는 쿼리를 작성해 봅시다.

-- 1번에서 작성한 쿼리를 기반으로, 집계 함수 SUM을 활용하여, 판매자 이름(SELLER_NAME), 
-- 상품 ID(PRODUCT_ID) 별 판매금액(PRICE * QUANTITY) 을 구할 수 있습니다.
-- 이를 활용하여 판매 ID(SELL_ID), 판매자 이름(SELLER_NAME), 상품 이름(PRODUCT_NAME), 
-- 수량(QUANTITY), 판매금액(PRICE * QUANTITY) 총 5개 컬럼을 조회하는 쿼리를 작성해 봅시다.

-- 아래는 PRODUCT, SELL 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC PRODUCT;
DESC SELL;

-- 1. SELL 테이블과 PRODUCT 테이블을 상품 ID 기준으로 INNER JOIN 하는 쿼리를 작성하세요.
select * from PRODUCT;
select * from SELL;


select SELL_ID,SELLER_NAME,PRODUCT_NAME, QUANTITY 
from SELL
INNER JOIN PRODUCT
on SELL.PRODUCT_ID = PRODUCT.PRODUCT_ID
order by SELL_ID asc;
-- 2. SUM 집계 함수를 이용하여, 판매자 이름, 상품 ID 별 판매 금액을 구하는 쿼리를 작성하세요.
select SELL_ID, SELLER_NAME, PRODUCT_NAME, QUANTITY,
SUM(PRICE*QUANTITY) OVER (PARTITION BY SELLER_NAME, SELL.PRODUCT_ID) SUM_PRICE
from SELL
INNER JOIN PRODUCT
on SELL.PRODUCT_ID = PRODUCT.PRODUCT_ID
order by SELL_ID asc;

-- 추가 컬럼
-- SUM(PRICE*QUANTITY) OVER (PARTITION BY SELLER_NAME) TOTAL_SUM_PRICE

+--------------+--------------+------+-----+---------+-------+
| Field        | Type         | Null | Key | Default | Extra |
+--------------+--------------+------+-----+---------+-------+
| PRODUCT_ID   | int(11)      | NO   | PRI | NULL    |       |
| PRODUCT_NAME | varchar(100) | YES  |     | NULL    |       |
| PRICE        | int(11)      | YES  |     | NULL    |       |
+--------------+--------------+------+-----+---------+-------+
+-------------+--------------+------+-----+---------+----------------+
| Field       | Type         | Null | Key | Default | Extra          |
+-------------+--------------+------+-----+---------+----------------+
| SELL_ID     | int(11)      | NO   | PRI | NULL    | auto_increment |
| PRODUCT_ID  | int(11)      | YES  |     | NULL    |                |
| QUANTITY    | int(11)      | YES  |     | NULL    |                |
| SELLER_NAME | varchar(100) | YES  |     | NULL    |                |
+-------------+--------------+------+-----+---------+----------------+
+------------+--------------+-------+
| PRODUCT_ID | PRODUCT_NAME | PRICE |
+------------+--------------+-------+
|          1 | Red Car      |  2000 |
|          2 | Blue Car     |  3500 |
|          3 | White Car    |  5000 |
|          4 | Black Car    |  8000 |
+------------+--------------+-------+
+---------+------------+----------+-------------+
| SELL_ID | PRODUCT_ID | QUANTITY | SELLER_NAME |
+---------+------------+----------+-------------+
|       1 |          1 |        2 | Kim         |
|       2 |          3 |        1 | Kim         |
|       3 |          4 |        2 | Kim         |
|       4 |          1 |        1 | Lee         |
|       5 |          2 |        1 | Lee         |
|       6 |          4 |        3 | Lee         |
|       7 |          1 |        3 | Choi        |
|       8 |          3 |       11 | Choi        |
+---------+------------+----------+-------------+
+---------+-------------+--------------+----------+
| SELL_ID | SELLER_NAME | PRODUCT_NAME | QUANTITY |
+---------+-------------+--------------+----------+
|       1 | Kim         | Red Car      |        2 |
|       2 | Kim         | White Car    |        1 |
|       3 | Kim         | Black Car    |        2 |
|       4 | Lee         | Red Car      |        1 |
|       5 | Lee         | Blue Car     |        1 |
|       6 | Lee         | Black Car    |        3 |
|       7 | Choi        | Red Car      |        3 |
|       8 | Choi        | White Car    |       11 |
+---------+-------------+--------------+----------+
+---------+-------------+--------------+----------+-----------+
| SELL_ID | SELLER_NAME | PRODUCT_NAME | QUANTITY | SUM_PRICE |
+---------+-------------+--------------+----------+-----------+
|       1 | Kim         | Red Car      |        2 |      4000 |
|       2 | Kim         | White Car    |        1 |      5000 |
|       3 | Kim         | Black Car    |        2 |     16000 |
|       4 | Lee         | Red Car      |        1 |      2000 |
|       5 | Lee         | Blue Car     |        1 |      3500 |
|       6 | Lee         | Black Car    |        3 |     24000 |
|       7 | Choi        | Red Car      |        3 |      6000 |
|       8 | Choi        | White Car    |       11 |     55000 |
+---------+-------------+--------------+----------+-----------+

-- [실습3] 윈도우 함수 - 그룹 내 행 순서 함수

-- 마라톤의 경기 기록을 위해 그룹별 참가자의 기록을 저장하고 있는 PARTICIPANT 테이블에는 ID,
--  그룹 번호, 시간 기록 정보가 있습니다.

-- 각 그룹에 대해서 참가자의 앞, 뒤 기록과 그룹 내 가장 빠른 기록, 가장 느린 기록을 구하려고 
-- 합니다. 해당 값들을 구하기 위해 앞에서 배웠던 그룹 내 행 순서 함수를 이용해 봅시다.

-- 각 그룹별로 나누어서, 참가자의 앞, 뒤 기록과 그룹 내에서 가장 빠른 기록, 가장 느린 기록을
--  조회하는 쿼리를 작성해 봅시다.

-- PARTICIPANT 테이블에서 그룹별 참가자의 앞, 뒤 기록과 그룹 내에서 가장 빠른 기록, 
-- 가장 느린 기록을 조회해 봅시다.
-- 앞, 뒤 기록을 조회하기 위해 LAG, LEAD를 활용하고 가장 빠른 기록, 가장 느린 기록을
--  조회하기 위해 FIRST_VALUE, LAST_VALUE를 활용하여, ID, 그룹 번호(GROUP_NUM), 
--  시간 기록(TIME_RECORD), 앞사람 기록(LAG), 뒷사람 기록(LEAD),  가장 빠른 기록
--  (FIRST_VALUE), 가장 느린 기록(LAST_VALUE) 을 조회하는 쿼리를 작성해 봅시다.

-- 아래는 PARTICIPANT 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC PARTICIPANT;

-- 그룹 별, 참가자의 앞, 뒤 기록과 그룹 내에서 가장 빠른 기록, 가장 느린 기록을 조회하세요.

select * from PARTICIPANT;

select ID, GROUP_NUM, TIME_RECORD,
LAG(TIME_RECORD,1) 
OVER (PARTITION BY GROUP_NUM ORDER BY TIME_RECORD) PREV_PARTICIPANT_RECORD,
LEAD(TIME_RECORD,1) 
OVER (PARTITION BY GROUP_NUM ORDER BY TIME_RECORD) AFTER_PARTICIPANT_RECORD,
FIRST_VALUE(TIME_RECORD)
OVER (PARTITION BY GROUP_NUM ORDER BY TIME_RECORD
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS PARTICIPANT_FAST_RECORD,
LAST_VALUE(TIME_RECORD)
OVER (PARTITION BY GROUP_NUM ORDER BY TIME_RECORD
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS PARTICIPANT_SLOW_RECORD
from PARTICIPANT;

+-------------+---------+------+-----+---------+----------------+
| Field       | Type    | Null | Key | Default | Extra          |
+-------------+---------+------+-----+---------+----------------+
| ID          | int(11) | NO   | PRI | NULL    | auto_increment |
| GROUP_NUM   | int(11) | YES  |     | NULL    |                |
| TIME_RECORD | time    | YES  |     | NULL    |                |
+-------------+---------+------+-----+---------+----------------+
+----+-----------+-------------+
| ID | GROUP_NUM | TIME_RECORD |
+----+-----------+-------------+
|  1 |         1 | 02:01:05    |
|  2 |         1 | 02:17:33    |
|  3 |         1 | 02:15:05    |
|  4 |         1 | 02:25:59    |
|  5 |         1 | 02:59:02    |
|  6 |         2 | 01:59:50    |
|  7 |         2 | 02:22:22    |
|  8 |         2 | 02:31:12    |
|  9 |         2 | 02:42:32    |
| 10 |         2 | 02:00:01    |
| 11 |         3 | 02:03:03    |
| 12 |         3 | 02:03:34    |
| 13 |         3 | 02:08:11    |
| 14 |         3 | 03:34:59    |
| 15 |         3 | 02:54:13    |
+----+-----------+-------------+

+----+-----------+-------------+-------------------------+--------------------------+-------------------------+-------------------------+
| ID | GROUP_NUM | TIME_RECORD | PREV_PARTICIPANT_RECORD | AFTER_PARTICIPANT_RECORD | PARTICIPANT_FAST_RECORD | PARTICIPANT_SLOW_RECORD |
+----+-----------+-------------+-------------------------+--------------------------+-------------------------+-------------------------+
|  1 |         1 | 02:01:05    | NULL                    | 02:15:05                 | 02:01:05                | 02:59:02                |
|  3 |         1 | 02:15:05    | 02:01:05                | 02:17:33                 | 02:01:05                | 02:59:02                |
|  2 |         1 | 02:17:33    | 02:15:05                | 02:25:59                 | 02:01:05                | 02:59:02                |
|  4 |         1 | 02:25:59    | 02:17:33                | 02:59:02                 | 02:01:05                | 02:59:02                |
|  5 |         1 | 02:59:02    | 02:25:59                | NULL                     | 02:01:05                | 02:59:02                |
|  6 |         2 | 01:59:50    | NULL                    | 02:00:01                 | 01:59:50                | 02:42:32                |
| 10 |         2 | 02:00:01    | 01:59:50                | 02:22:22                 | 01:59:50                | 02:42:32                |
|  7 |         2 | 02:22:22    | 02:00:01                | 02:31:12                 | 01:59:50                | 02:42:32                |
|  8 |         2 | 02:31:12    | 02:22:22                | 02:42:32                 | 01:59:50                | 02:42:32                |
|  9 |         2 | 02:42:32    | 02:31:12                | NULL                     | 01:59:50                | 02:42:32                |
| 11 |         3 | 02:03:03    | NULL                    | 02:03:34                 | 02:03:03                | 03:34:59                |
| 12 |         3 | 02:03:34    | 02:03:03                | 02:08:11                 | 02:03:03                | 03:34:59                |
| 13 |         3 | 02:08:11    | 02:03:34                | 02:54:13                 | 02:03:03                | 03:34:59                |
| 15 |         3 | 02:54:13    | 02:08:11                | 03:34:59                 | 02:03:03                | 03:34:59                |
| 14 |         3 | 03:34:59    | 02:54:13                | NULL                     | 02:03:03                | 03:34:59                |
+----+-----------+-------------+-------------------------+--------------------------+-------------------------+-------------------------+

-- [실습4] 윈도우 함수 - 그룹 내 비율 함수(RATIO_TO_REPORT)

-- BUDGET_USE 테이블에는 ID, 사용 코드, 비용 정보가 담겨있습니다.

-- 예산 사용 테이블, BUDGET_USE 테이블에서 각 비용이 전체 비용 
-- 합계에서 차지하는 비율을 백분율(소수점 5번째 자리에서 반올림)로 조회해 봅시다.

-- 지시사항
-- BUDGET_USE 테이블에서 비용(EXPENSE)이 전체 비용 합계(SUM(EXPENSE))에서 
-- 차지하는 비율을 구해 ID, 사용 코드(USE_CODE), 비용(EXPENSE), 비율(RATIO)로 조회해 봅시다.
-- 이때, 비율 값은 ROUND 함수를 이용하여 소수점 5번째 자리에서 반올림합니다.

-- Tips!
-- ROUND() 함수는, ROUND(값, 값을 표현할 자리수)와 같이 사용할 수 있습니다.
-- 결과에 대해 ORDER BY 를 이용하여 ID를 기준으로 오름차순 정렬을 해주세요.
-- 데이터 조회순서는 지시사항에서 언급하고 있는 순서대로 정확히 작성하세요.

-- 아래는 BUDGET_USE 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC BUDGET_USE;
select * from BUDGET_USE;
-- 비용이 전체 비용 합계에서 차지하는 비율을 조회해 봅시다.

select ID, USE_CODE, EXPENSE,
ROUND((EXPENSE/ SUM(EXPENSE) OVER())*100,4) AS RATIO_TO_REPORT
from BUDGET_USE
order by ID asc;

+----------+---------+------+-----+---------+----------------+
| Field    | Type    | Null | Key | Default | Extra          |
+----------+---------+------+-----+---------+----------------+
| ID       | int(11) | NO   | PRI | NULL    | auto_increment |
| USE_CODE | int(11) | YES  |     | NULL    |                |
| EXPENSE  | int(11) | YES  |     | NULL    |                |
+----------+---------+------+-----+---------+----------------+
+----+----------+---------+
| ID | USE_CODE | EXPENSE |
+----+----------+---------+
|  1 |        1 | 1000000 |
|  2 |        2 |   50000 |
|  3 |        1 | 1200000 |
|  4 |        1 | 2000000 |
|  5 |        2 |  230000 |
|  6 |        2 |  150000 |
|  7 |        1 |  800000 |
|  8 |        1 | 2000000 |
|  9 |        1 | 1000000 |
+----+----------+---------+
+----+----------+---------+-----------------+
| ID | USE_CODE | EXPENSE | RATIO_TO_REPORT |
+----+----------+---------+-----------------+
|  1 |        1 | 1000000 |         11.8624 |
|  2 |        2 |   50000 |          0.5931 |
|  3 |        1 | 1200000 |         14.2349 |
|  4 |        1 | 2000000 |         23.7248 |
|  5 |        2 |  230000 |          2.7284 |
|  6 |        2 |  150000 |          1.7794 |
|  7 |        1 |  800000 |          9.4899 |
|  8 |        1 | 2000000 |         23.7248 |
|  9 |        1 | 1000000 |         11.8624 |
+----+----------+---------+-----------------+

-- [실습5] 윈도우 함수 - 그룹 내 비율 함수(PERCENT_RANK, CUME_DIST)

-- STUDENT 테이블에는 ID, 수학 점수, 물리 점수, 화학 점수 정보가 담겨있습니다.

-- 학생들의 수학, 물리, 화학 점수의 총합에 대해서 상위 몇%에 해당하는지에 대한 
-- 백분율 순위와, 누적 분포도 백분율 값에 대해서 알아보고자 합니다.

-- 학생들의 수학, 물리, 화학 점수의 총합을 기준으로 고득점자 순위로 정렬하고 PERCENT_RANK를
--  활용한 백분율 순위와 CUME_DIST를 활용한 누적 백분율을 조회하는 쿼리를 작성해 봅시다.

--  STUDENT 테이블에서 수학 점수(MATH), 물리 점수(PHYSICS), 화학 점수(CHEMISTRY) 를 
--  모두 합한 총합 점수(SCORE_SUM) 를 구하고, 총합 점수에 대해 내림차순 정렬을 기준으로 
--  백분율 순위(PERCENT_RANK), 누적 백분율(CUME_DIST) 를 구해봅시다.
-- 해당 값들을 통해 ID, 수학 점수(MATH), 물리 점수(PHYSICS), 화학 점수(CHEMISTRY), 
-- 총합 점수(SCORE_SUM), 백분율 순위(PERCENT_RANK), 누적 백분율(CUME_DIST) 를 조회하는 쿼리를 작성해 봅시다.

-- 아래는 STUDENT 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC STUDENT;

select * from STUDENT;
-- 학생들의 수학, 물리, 화학 점수의 총합을 기준으로 백분율 순위와 누적 백분율을 조회하는 쿼리를 작성하세요.

select ID, MATH, PHYSICS, CHEMISTRY,
    (MATH+PHYSICS+CHEMISTRY) AS SCORE_SUM,
    PERCENT_RANK() OVER(ORDER BY SCORE_SUM DESC)
    AS PERCENT_RANK,
    CUME_DIST() OVER(ORDER BY SCORE_SUM DESC)
    AS CUME_DIST
from STUDENT
order by SCORE_SUM DESC;

+-----------+---------+------+-----+---------+----------------+
| Field     | Type    | Null | Key | Default | Extra          |
+-----------+---------+------+-----+---------+----------------+
| ID        | int(11) | NO   | PRI | NULL    | auto_increment |
| MATH      | int(11) | YES  |     | NULL    |                |
| PHYSICS   | int(11) | YES  |     | NULL    |                |
| CHEMISTRY | int(11) | YES  |     | NULL    |                |
+-----------+---------+------+-----+---------+----------------+
+----+------+---------+-----------+
| ID | MATH | PHYSICS | CHEMISTRY |
+----+------+---------+-----------+
|  1 |   42 |      18 |        35 |
|  2 |    1 |      20 |        25 |
|  3 |   79 |       9 |        13 |
|  4 |   65 |       6 |        46 |
|  5 |   82 |      28 |        12 |
|  6 |   92 |      46 |        43 |
|  7 |   28 |      37 |        42 |
|  8 |    5 |       3 |         4 |
|  9 |   93 |      33 |        22 |
| 10 |   17 |      19 |        46 |
| 11 |   48 |      27 |        22 |
| 12 |   39 |      20 |        13 |
| 13 |   68 |      50 |        36 |
| 14 |   95 |       4 |        12 |
| 15 |   23 |      34 |        24 |
| 16 |   65 |      42 |        12 |
| 17 |   54 |      19 |        48 |
| 18 |   45 |      13 |         8 |
| 19 |   38 |      10 |        24 |
| 20 |   42 |      30 |        29 |
| 21 |   17 |      36 |        41 |
| 22 |   43 |      39 |         7 |
| 23 |   41 |      43 |        15 |
| 24 |   49 |      47 |         6 |
| 25 |   91 |      30 |        21 |
| 26 |   51 |       7 |         2 |
| 27 |   94 |      49 |        30 |
| 28 |   24 |      35 |         5 |
| 29 |   57 |      41 |        17 |
| 30 |   77 |      32 |         9 |
| 31 |   45 |      40 |        27 |
| 32 |   24 |      38 |        39 |
| 33 |   19 |      33 |        30 |
| 34 |   42 |      34 |        16 |
| 35 |   40 |       9 |         5 |
| 36 |   31 |      28 |         7 |
| 37 |   74 |      37 |        22 |
| 38 |   46 |      25 |        23 |
| 39 |   71 |      30 |        28 |
| 40 |   74 |      48 |        13 |
| 41 |   87 |      41 |        12 |
| 42 |   37 |       6 |        18 |
| 43 |   56 |      25 |        32 |
| 44 |   53 |       1 |         1 |
| 45 |   42 |      25 |        17 |
| 46 |   31 |       8 |        42 |
| 47 |    8 |      38 |         8 |
| 48 |   88 |       4 |        34 |
| 49 |   46 |      10 |        10 |
| 50 |   59 |      22 |        39 |
+----+------+---------+-----------+
+----+------+---------+-----------+-----------+--------------+--------------+
| ID | MATH | PHYSICS | CHEMISTRY | SCORE_SUM | PERCENT_RANK | CUME_DIST    |
+----+------+---------+-----------+-----------+--------------+--------------+
|  6 |   92 |      46 |        43 |       181 | 0.0000000000 | 0.0200000000 |
| 27 |   94 |      49 |        30 |       173 | 0.0204081633 | 0.0400000000 |
| 13 |   68 |      50 |        36 |       154 | 0.0408163265 | 0.0600000000 |
|  9 |   93 |      33 |        22 |       148 | 0.0612244898 | 0.0800000000 |
| 25 |   91 |      30 |        21 |       142 | 0.0816326531 | 0.1000000000 |
| 41 |   87 |      41 |        12 |       140 | 0.1020408163 | 0.1200000000 |
| 40 |   74 |      48 |        13 |       135 | 0.1224489796 | 0.1400000000 |
| 37 |   74 |      37 |        22 |       133 | 0.1428571429 | 0.1600000000 |
| 39 |   71 |      30 |        28 |       129 | 0.1632653061 | 0.1800000000 |
| 48 |   88 |       4 |        34 |       126 | 0.1836734694 | 0.2000000000 |
|  5 |   82 |      28 |        12 |       122 | 0.2040816327 | 0.2200000000 |
| 17 |   54 |      19 |        48 |       121 | 0.2244897959 | 0.2400000000 |
| 50 |   59 |      22 |        39 |       120 | 0.2448979592 | 0.2600000000 |
| 16 |   65 |      42 |        12 |       119 | 0.2653061224 | 0.2800000000 |
| 30 |   77 |      32 |         9 |       118 | 0.2857142857 | 0.3000000000 |
|  4 |   65 |       6 |        46 |       117 | 0.3061224490 | 0.3200000000 |
| 29 |   57 |      41 |        17 |       115 | 0.3265306122 | 0.3400000000 |
| 43 |   56 |      25 |        32 |       113 | 0.3469387755 | 0.3600000000 |
| 31 |   45 |      40 |        27 |       112 | 0.3673469388 | 0.3800000000 |
| 14 |   95 |       4 |        12 |       111 | 0.3877551020 | 0.4000000000 |
|  7 |   28 |      37 |        42 |       107 | 0.4081632653 | 0.4200000000 |
| 24 |   49 |      47 |         6 |       102 | 0.4285714286 | 0.4400000000 |
| 32 |   24 |      38 |        39 |       101 | 0.4489795918 | 0.5000000000 |
|  3 |   79 |       9 |        13 |       101 | 0.4489795918 | 0.5000000000 |
| 20 |   42 |      30 |        29 |       101 | 0.4489795918 | 0.5000000000 |
| 23 |   41 |      43 |        15 |        99 | 0.5102040816 | 0.5200000000 |
| 11 |   48 |      27 |        22 |        97 | 0.5306122449 | 0.5400000000 |
|  1 |   42 |      18 |        35 |        95 | 0.5510204082 | 0.5600000000 |
| 38 |   46 |      25 |        23 |        94 | 0.5714285714 | 0.6000000000 |
| 21 |   17 |      36 |        41 |        94 | 0.5714285714 | 0.6000000000 |
| 34 |   42 |      34 |        16 |        92 | 0.6122448980 | 0.6200000000 |
| 22 |   43 |      39 |         7 |        89 | 0.6326530612 | 0.6400000000 |
| 45 |   42 |      25 |        17 |        84 | 0.6530612245 | 0.6600000000 |
| 33 |   19 |      33 |        30 |        82 | 0.6734693878 | 0.7000000000 |
| 10 |   17 |      19 |        46 |        82 | 0.6734693878 | 0.7000000000 |
| 46 |   31 |       8 |        42 |        81 | 0.7142857143 | 0.7400000000 |
| 15 |   23 |      34 |        24 |        81 | 0.7142857143 | 0.7400000000 |
| 12 |   39 |      20 |        13 |        72 | 0.7551020408 | 0.7800000000 |
| 19 |   38 |      10 |        24 |        72 | 0.7551020408 | 0.7800000000 |
| 49 |   46 |      10 |        10 |        66 | 0.7959183673 | 0.8400000000 |
| 18 |   45 |      13 |         8 |        66 | 0.7959183673 | 0.8400000000 |
| 36 |   31 |      28 |         7 |        66 | 0.7959183673 | 0.8400000000 |
| 28 |   24 |      35 |         5 |        64 | 0.8571428571 | 0.8600000000 |
| 42 |   37 |       6 |        18 |        61 | 0.8775510204 | 0.8800000000 |
| 26 |   51 |       7 |         2 |        60 | 0.8979591837 | 0.9000000000 |
| 44 |   53 |       1 |         1 |        55 | 0.9183673469 | 0.9200000000 |
| 35 |   40 |       9 |         5 |        54 | 0.9387755102 | 0.9600000000 |
| 47 |    8 |      38 |         8 |        54 | 0.9387755102 | 0.9600000000 |
|  2 |    1 |      20 |        25 |        46 | 0.9795918367 | 0.9800000000 |
|  8 |    5 |       3 |         4 |        12 | 1.0000000000 | 1.0000000000 |
+----+------+---------+-----------+-----------+--------------+--------------+

-- [실습6] 윈도우 함수 - 그룹 내 비율 함수(NTILE)

-- STUDENT 테이블에는 ID, 수학 점수, 물리 점수, 화학 점수 정보가 담겨있습니다.

-- 학생들의 점수 총합을 기준으로 3개 반으로 나누어 구분지으려고 합니다.

-- 학생들의 수학, 물리, 화학 점수의 총합을 기준으로 NTILE을 이용하여 3개의 그룹으로 나누어 조회하는 쿼리를 작성해 봅시다.

-- STUDENT 테이블에서 수학 점수(MATH), 물리 점수(PHYSICS), 화학 점수(CHEMISTRY) 를 모두 합한 총합 점수(SCORE_SUM) 를 구하고, NTILE을 이용하여 총합 점수 내림차순 기준, 3개의 그룹 으로 나누어 봅시다.
-- 해당 값들을 통해 ID, 수학 점수(MATH), 물리 점수(PHYSICS), 화학 점수(CHEMISTRY), 총합 점수(SCORE_SUM), 그룹 값(NTILE) 을 조회하는 쿼리를 작성해 봅시다.

-- 아래는 STUDENT 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC STUDENT;
select * from STUDENT;
-- 학생들의 수학, 물리, 화학 점수의 총합 내림차순 기준으로 3개의 그룹으로 나누어 조회하는 쿼리를 작성하세요.

select ID, MATH,PHYSICS,CHEMISTRY,
    (MATH+PHYSICS+CHEMISTRY) AS SCORE_SUM,
    NTILE(3) OVER(ORDER BY SCORE_SUM DESC)
    AS NTILE
from STUDENT
order by ID asc;

+-----------+---------+------+-----+---------+----------------+
| Field     | Type    | Null | Key | Default | Extra          |
+-----------+---------+------+-----+---------+----------------+
| ID        | int(11) | NO   | PRI | NULL    | auto_increment |
| MATH      | int(11) | YES  |     | NULL    |                |
| PHYSICS   | int(11) | YES  |     | NULL    |                |
| CHEMISTRY | int(11) | YES  |     | NULL    |                |
+-----------+---------+------+-----+---------+----------------+
+----+------+---------+-----------+
| ID | MATH | PHYSICS | CHEMISTRY |
+----+------+---------+-----------+
|  1 |  100 |      50 |        50 |
|  2 |   57 |      32 |        47 |
|  3 |   88 |      39 |        41 |
|  4 |   92 |      44 |        31 |
|  5 |   17 |      50 |        50 |
|  6 |  100 |       8 |         7 |
|  7 |   77 |      45 |        45 |
|  8 |   69 |      36 |        46 |
|  9 |   81 |      47 |        40 |
| 10 |   66 |      36 |        35 |
+----+------+---------+-----------+
+----+------+---------+-----------+-----------+-------+
| ID | MATH | PHYSICS | CHEMISTRY | SCORE_SUM | NTILE |
+----+------+---------+-----------+-----------+-------+
|  1 |  100 |      50 |        50 |       200 |     1 |
|  2 |   57 |      32 |        47 |       136 |     3 |
|  3 |   88 |      39 |        41 |       168 |     1 |
|  4 |   92 |      44 |        31 |       167 |     1 |
|  5 |   17 |      50 |        50 |       117 |     3 |
|  6 |  100 |       8 |         7 |       115 |     3 |
|  7 |   77 |      45 |        45 |       167 |     2 |
|  8 |   69 |      36 |        46 |       151 |     2 |
|  9 |   81 |      47 |        40 |       168 |     1 |
| 10 |   66 |      36 |        35 |       137 |     2 |
+----+------+---------+-----------+-----------+-------+


-- [실습7] 그룹 함수 - GROUP BY

-- BOOK_HISTORY 테이블에는 책 ID, 책 이름, 책 종류, 책 카테고리, 판매 개수 정보가 담겨있습니다.

-- 판매 현황을 알아보기 위해서, 책 종류와 책 카테고리 묶음 별로 몇 권씩 판매되었는지 확인해보려고 합니다.

-- 책 판매 기록에서, 책 종류와 책 카테고리를 기준으로 GROUP BY를 이용해 그룹화하여 총 판매 개수를 구하는 쿼리를 작성해 봅시다.

-- 지시사항
-- BOOK_HISTORY 테이블에서 책 종류(KIND)와 책 카테고리(CATEGORY) 를 기준으로 GROUP BY와 SUM()을 이용하여 책 종류(KIND), 책 카테고리(CATEGORY), 판매 개수 합(SUM(SELL_COUNT)) 을 조회하는 쿼리를 작성해 봅시다.

-- 아래는 BOOK_HISTORY 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC BOOK_HISTORY;

select * from BOOK_HISTORY;
-- 책 종류와 책 카테고리로 그룹화 하여 각 그룹당 판매 개수 합을 구해보세요.

select KIND,CATEGORY, SUM(SELL_COUNT)
from BOOK_HISTORY
group by KIND, CATEGORY
order by SUM(SELL_COUNT) asc;

+------------+--------------+------+-----+---------+----------------+
| Field      | Type         | Null | Key | Default | Extra          |
+------------+--------------+------+-----+---------+----------------+
| BOOK_ID    | int(11)      | NO   | PRI | NULL    | auto_increment |
| BOOK_NAME  | varchar(100) | YES  |     | NULL    |                |
| KIND       | varchar(100) | YES  |     | NULL    |                |
| CATEGORY   | varchar(100) | YES  |     | NULL    |                |
| SELL_COUNT | int(11)      | YES  |     | NULL    |                |
+------------+--------------+------+-----+---------+----------------+
+---------+-----------+------------+----------+------------+
| BOOK_ID | BOOK_NAME | KIND       | CATEGORY | SELL_COUNT |
+---------+-----------+------------+----------+------------+
|    1001 | SQL       | PAPER BOOK | DEV      |         10 |
|    1002 | PASTA     | PAPER BOOK | COOK     |          1 |
|    1003 | KOREA     | E BOOK     | CULTURE  |          3 |
|    1004 | JAVA      | E BOOK     | DEV      |          5 |
|    1005 | DATA      | PAPER BOOK | DEV      |          2 |
|    1006 | SALAD     | E BOOK     | COOK     |          5 |
|    1007 | PIZZA     | PAPER BOOK | COOK     |          7 |
|    1008 | JAPAN     | E BOOK     | CULTURE  |          1 |
|    1009 | PYTHON    | E BOOK     | DEV      |         11 |
|    1010 | BREAD     | E BOOK     | COOK     |          8 |
|    1011 | CHINA     | PAPER BOOK | CULTURE  |          2 |
+---------+-----------+------------+----------+------------+
+------------+----------+-----------------+
| KIND       | CATEGORY | SUM(SELL_COUNT) |
+------------+----------+-----------------+
| PAPER BOOK | CULTURE  |               2 |
| E BOOK     | CULTURE  |               4 |
| PAPER BOOK | COOK     |               8 |
| PAPER BOOK | DEV      |              12 |
| E BOOK     | COOK     |              13 |
| E BOOK     | DEV      |              16 |
+------------+----------+-----------------+

-- [실습8] 그룹 함수 - ROLL UP

-- 이전 문제와 같이 BOOK_HISTORY 테이블에는 책 ID, 책 이름, 책 종류, 책 카테고리, 판매 개수 정보가 담겨있습니다.

-- 이번에도 앞에서와 같이 책 종류와 책 카테고리 묶음 별 판매개수를 알고자하는데, 책 종류 기준으로의 판매개수 정보와 전체 판매개수 정보도 함께 알고자합니다.

-- 책 판매 기록에서, 책 종류와 책 카테고리를 기준으로 GROUP BY를 이용해 그룹화하고 ROLLUP을 이용하여 총 판매 개수를 구하는 쿼리를 작성해 봅시다.

-- 지시사항
-- BOOK_HISTORY 테이블에서 책 종류(KIND)와 책 카테고리(CATEGORY) 를 기준으로 GROUP BY와 SUM()을 이용하여 책 종류(KIND), 책 카테고리(CATEGORY), 판매 개수 합(SUM) 을 조회하는 쿼리를 작성해 봅시다.
-- 이때, ROLLUP을 이용하여 그룹화하는 컬럼에 대한 부분적인 통계를 함께 조회해 봅시다.

-- 아래는 BOOK_HISTORY 테이블에 대한 구조를 보여줍니다. 테이블을 수정하실 필요는 없습니다.
DESC BOOK_HISTORY;

select * from BOOK_HISTORY;
-- 책 종류와 책 카테고리로 그룹화 하고 ROLLUP을 이용하여 각 그룹당 판매 개수 합을 구해보세요.

select KIND, CATEGORY, SUM(SELL_COUNT)
from BOOK_HISTORY
group by KIND, CATEGORY with ROLLUP;

+------------+--------------+------+-----+---------+----------------+
| Field      | Type         | Null | Key | Default | Extra          |
+------------+--------------+------+-----+---------+----------------+
| BOOK_ID    | int(11)      | NO   | PRI | NULL    | auto_increment |
| BOOK_NAME  | varchar(100) | YES  |     | NULL    |                |
| KIND       | varchar(100) | YES  |     | NULL    |                |
| CATEGORY   | varchar(100) | YES  |     | NULL    |                |
| SELL_COUNT | int(11)      | YES  |     | NULL    |                |
+------------+--------------+------+-----+---------+----------------+
+---------+-----------+------------+----------+------------+
| BOOK_ID | BOOK_NAME | KIND       | CATEGORY | SELL_COUNT |
+---------+-----------+------------+----------+------------+
|    1001 | SQL       | PAPER BOOK | DEV      |         10 |
|    1002 | PASTA     | PAPER BOOK | COOK     |          1 |
|    1003 | KOREA     | E BOOK     | CULTURE  |          3 |
|    1004 | JAVA      | E BOOK     | DEV      |          5 |
|    1005 | DATA      | PAPER BOOK | DEV      |          2 |
|    1006 | SALAD     | E BOOK     | COOK     |          5 |
|    1007 | PIZZA     | PAPER BOOK | COOK     |          7 |
|    1008 | JAPAN     | E BOOK     | CULTURE  |          1 |
|    1009 | PYTHON    | E BOOK     | DEV      |         11 |
|    1010 | BREAD     | E BOOK     | COOK     |          8 |
|    1011 | CHINA     | PAPER BOOK | CULTURE  |          2 |
+---------+-----------+------------+----------+------------+
+------------+----------+-----------------+
| KIND       | CATEGORY | SUM(SELL_COUNT) |
+------------+----------+-----------------+
| E BOOK     | COOK     |              13 |
| E BOOK     | CULTURE  |               4 |
| E BOOK     | DEV      |              16 |
| E BOOK     | NULL     |              33 |
| PAPER BOOK | COOK     |               8 |
| PAPER BOOK | CULTURE  |               2 |
| PAPER BOOK | DEV      |              12 |
| PAPER BOOK | NULL     |              22 |
| NULL       | NULL     |              55 |
+------------+----------+-----------------+